// å…¨å±€å˜é‡
const API_BASE_URL = 'http://localhost:8000';
let currentConfig = {
    llm: {
        type: 'local',
        url: 'http://192.168.22.191:8000/v1',
        model: '/home/aiteam/.cache/modelscope/hub/models/google/medgemma-27b-text-it/',
        key: 'EMPTY',
        temperature: 0.3
    },
    embedding: {
        type: 'local-api',
        url: 'http://192.168.22.191:8000/v1',
        key: 'EMPTY',
        model: 'auto',
        dimension: 4096
    }
};

let charts = {};
let currentFiles = [];
let generationInProgress = false;

// HTMLè½¬ä¹‰å‡½æ•°ï¼Œé˜²æ­¢XSSæ”»å‡»
function escapeHtml(text) {
    // ç¡®ä¿è¾“å…¥æ˜¯å­—ç¬¦ä¸²
    if (typeof text !== 'string') {
        text = String(text || '');
    }
    
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, function(m) { return map[m]; });
}

// è°ƒè¯•å‡½æ•°ï¼šæ£€æŸ¥é¡µé¢å…ƒç´ 
function debugCheckElements() {
    console.log('=== é¡µé¢å…ƒç´ æ£€æŸ¥ ===');
    
    // æ£€æŸ¥åµŒå…¥æ¨¡å‹ç›¸å…³å…ƒç´ 
    const embedElements = {
        'embed-type': document.getElementById('embed-type'),
        'embed-url-group': document.getElementById('embed-url-group'),
        'embed-key-group': document.getElementById('embed-key-group'),
        'embed-url': document.getElementById('embed-url'),
        'embed-key': document.getElementById('embed-key'),
        'embed-model': document.getElementById('embed-model'),
        'embed-dim': document.getElementById('embed-dim')
    };
    
    console.log('åµŒå…¥æ¨¡å‹å…ƒç´ :', embedElements);
    
    // æ£€æŸ¥æ–‡ä»¶ä¸Šä¼ ç›¸å…³å…ƒç´ 
    const fileElements = {
        'drag-drop-area': document.getElementById('drag-drop-area'),
        'file-input': document.getElementById('file-input')
    };
    
    console.log('æ–‡ä»¶ä¸Šä¼ å…ƒç´ :', fileElements);
    
    // æ£€æŸ¥é…ç½®æ ‡ç­¾é¡µ
    const configTab = document.getElementById('config');
    console.log('é…ç½®æ ‡ç­¾é¡µ:', configTab);
    
    if (configTab) {
        console.log('é…ç½®æ ‡ç­¾é¡µæ˜¯å¦å¯è§:', !configTab.classList.contains('active') ? 'éšè—' : 'æ˜¾ç¤º');
    }
    
    console.log('=== æ£€æŸ¥å®Œæˆ ===');
}

// é¡µé¢åˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', function() {
    console.log('é¡µé¢å¼€å§‹åˆå§‹åŒ–...');
    
    // å»¶è¿Ÿæ‰§è¡Œè°ƒè¯•æ£€æŸ¥ï¼Œç¡®ä¿æ‰€æœ‰DOMéƒ½å·²åŠ è½½
    setTimeout(() => {
        debugCheckElements();
    }, 100);
      initializeInterface();
    loadConfiguration();
    checkSystemStatus();
    initializeCharts();
    setupEventListeners();
    initializeMermaid();
    initializeChat();
    initializeModalEventListeners(); // åˆå§‹åŒ–æ¨¡æ€æ¡†äº‹ä»¶ç›‘å¬å™¨
    
    // å¤šæ¬¡å°è¯•åˆå§‹åŒ–åµŒå…¥æ¨¡å‹é…ç½®æ˜¾ç¤ºï¼Œç¡®ä¿é…ç½®æ­£ç¡®åº”ç”¨
    setTimeout(() => {
        console.log('ç¬¬ä¸€æ¬¡æ›´æ–°åµŒå…¥æ¨¡å‹é…ç½®æ˜¾ç¤º...');
        applyConfigurationToUI();
    }, 200);
    
    setTimeout(() => {
        console.log('ç¬¬äºŒæ¬¡å¼ºåˆ¶æ›´æ–°åµŒå…¥æ¨¡å‹é…ç½®æ˜¾ç¤º...');
        toggleEmbeddingConfigDisplay();
    }, 500);
    
    setTimeout(() => {
        console.log('ç¬¬ä¸‰æ¬¡ç¡®è®¤åµŒå…¥æ¨¡å‹é…ç½®æ˜¾ç¤º...');
        toggleEmbeddingConfigDisplay();
    }, 1000);
});

// åˆå§‹åŒ–ç•Œé¢
function initializeInterface() {
    console.log('åˆå§‹åŒ–ç•Œé¢...');
    
    // è®¾ç½®æ ‡ç­¾é¡µåˆ‡æ¢
    const navButtons = document.querySelectorAll('.nav-btn');
    navButtons.forEach(btn => {
        btn.addEventListener('click', () => switchTab(btn.dataset.tab));
    });

    // è®¾ç½®æµç¨‹å¯è§†åŒ–æ ‡ç­¾é¡µ
    const processTabButtons = document.querySelectorAll('.process-tab-btn');
    processTabButtons.forEach(btn => {
        btn.addEventListener('click', () => switchProcessTab(btn.dataset.processTab));
    });

    // è®¾ç½®æ¸©åº¦èŒƒå›´æ»‘å—
    const tempSlider = document.getElementById('llm-temp');
    const tempValue = document.getElementById('temp-value');
    if (tempSlider && tempValue) {
        tempSlider.addEventListener('input', function() {
            tempValue.textContent = this.value;
            currentConfig.llm.temperature = parseFloat(this.value);
        });
    }
}

// æ ‡ç­¾é¡µåˆ‡æ¢
function switchTab(tabName) {
    console.log('åˆ‡æ¢åˆ°æ ‡ç­¾é¡µ:', tabName);
    
    // éšè—æ‰€æœ‰æ ‡ç­¾é¡µå†…å®¹
    document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
    });
    
    // ç§»é™¤æ‰€æœ‰å¯¼èˆªæŒ‰é’®çš„æ¿€æ´»çŠ¶æ€
    document.querySelectorAll('.nav-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // æ˜¾ç¤ºé€‰ä¸­çš„æ ‡ç­¾é¡µ
    const targetTab = document.getElementById(tabName);
    const targetBtn = document.querySelector(`[data-tab="${tabName}"]`);
    
    if (targetTab) targetTab.classList.add('active');
    if (targetBtn) targetBtn.classList.add('active');
    
    // æ ¹æ®æ ‡ç­¾é¡µæ‰§è¡Œç‰¹å®šåˆå§‹åŒ–
    switch(tabName) {
        case 'home':
            checkSystemStatus();
            break;
        case 'config':
            // ç¡®ä¿é…ç½®é¡µé¢æ­£ç¡®æ˜¾ç¤º
            setTimeout(() => {
                toggleEmbeddingConfigDisplay();
            }, 100);
            break;
        case 'upload':
            // é‡æ–°è®¾ç½®æ–‡ä»¶ä¸Šä¼ äº‹ä»¶ç›‘å¬å™¨
            setupFileUploadListeners();
            loadKnowledgeStats();
            loadFileList();
            break;
        case 'process':
            renderProcessCharts();
            break;
        case 'chat':
            updateCurrentModelDisplay();
            // checkChatConnection();
            break;
        default:
            break;
    }
}

// æµç¨‹å¯è§†åŒ–æ ‡ç­¾é¡µåˆ‡æ¢
function switchProcessTab(tabName) {
    document.querySelectorAll('.process-tab-content').forEach(tab => {
        tab.classList.remove('active');
    });
    document.querySelectorAll('.process-tab-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    document.getElementById(tabName).classList.add('active');
    document.querySelector(`[data-process-tab="${tabName}"]`).classList.add('active');
}

// åˆå§‹åŒ–Mermaidå›¾è¡¨
function initializeMermaid() {
    if (typeof mermaid !== 'undefined') {
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#2563eb',
                primaryTextColor: '#1e293b',
                primaryBorderColor: '#e2e8f0',
                lineColor: '#64748b',
                secondaryColor: '#f8fafc',
                tertiaryColor: '#f1f5f9'
            }
        });
    }
}

// åˆ‡æ¢åµŒå…¥æ¨¡å‹é…ç½®æ˜¾ç¤º
function toggleEmbeddingConfigDisplay() {
    console.log('åˆ‡æ¢åµŒå…¥æ¨¡å‹é…ç½®æ˜¾ç¤º...');
    
    const embedType = document.getElementById('embed-type');
    const urlGroup = document.getElementById('embed-url-group');
    const keyGroup = document.getElementById('embed-key-group');
    
    if (!embedType || !urlGroup || !keyGroup) {
        console.error('åµŒå…¥æ¨¡å‹é…ç½®å…ƒç´ æœªæ‰¾åˆ°');
        return;
    }
    
    const selectedType = embedType.value;
    console.log('å½“å‰åµŒå…¥æ¨¡å‹ç±»å‹:', selectedType);
    
    if (selectedType === 'openai' || selectedType === 'local-api') {
        console.log('æ˜¾ç¤ºAPIé…ç½®å­—æ®µ');
        urlGroup.style.display = 'block';
        keyGroup.style.display = 'block';
        
        // æ›´æ–°æ¨¡å‹åç§°æç¤º
        const modelInput = document.getElementById('embed-model');
        if (modelInput) {
            if (selectedType === 'openai') {
                modelInput.placeholder = 'ä¾‹å¦‚: text-embedding-ada-002';
                if (modelInput.value === 'auto' || modelInput.value === 'all-MiniLM-L6-v2') {
                    modelInput.value = 'text-embedding-ada-002';
                }
            } else if (selectedType === 'local-api') {
                modelInput.placeholder = 'è¾“å…¥autoè‡ªåŠ¨è·å–ï¼Œæˆ–æŒ‡å®šæ¨¡å‹åç§°';
                if (modelInput.value === 'text-embedding-ada-002' || modelInput.value === 'all-MiniLM-L6-v2') {
                    modelInput.value = 'auto';
                }
            }
        }
    } else {
        console.log('éšè—APIé…ç½®å­—æ®µ');
        urlGroup.style.display = 'none';
        keyGroup.style.display = 'none';
        
        // SentenceTransformersæ¨¡å‹
        const modelInput = document.getElementById('embed-model');
        if (modelInput) {
            modelInput.placeholder = 'ä¾‹å¦‚: all-MiniLM-L6-v2';
            if (modelInput.value === 'text-embedding-ada-002' || modelInput.value === 'auto') {
                modelInput.value = 'all-MiniLM-L6-v2';
            }
        }
    }
}

// ä¸“é—¨è®¾ç½®æ–‡ä»¶ä¸Šä¼ äº‹ä»¶ç›‘å¬å™¨
function setupFileUploadListeners() {
    console.log('=== è®¾ç½®æ–‡ä»¶ä¸Šä¼ äº‹ä»¶ç›‘å¬å™¨ ===');
    
    const dragDropArea = document.getElementById('drag-drop-area');
    const fileInput = document.getElementById('file-input');

    console.log('æ–‡ä»¶ä¸Šä¼ å…ƒç´ æ£€æŸ¥:', { 
        dragDropArea: !!dragDropArea, 
        fileInput: !!fileInput,
        dragDropAreaVisible: dragDropArea ? dragDropArea.offsetParent !== null : false,
        fileInputVisible: fileInput ? fileInput.offsetParent !== null : false
    });

    if (!dragDropArea || !fileInput) {
        console.error('âŒ æ–‡ä»¶ä¸Šä¼ å…ƒç´ æœªæ‰¾åˆ°!', { dragDropArea, fileInput });
        return;
    }

    // ç§»é™¤å¯èƒ½å­˜åœ¨çš„æ—§äº‹ä»¶ç›‘å¬å™¨
    const newDragDropArea = dragDropArea.cloneNode(true);
    const newFileInput = newDragDropArea.querySelector('#file-input');
    dragDropArea.parentNode.replaceChild(newDragDropArea, dragDropArea);

    console.log('âœ… å¼€å§‹ç»‘å®šæ–‡ä»¶ä¸Šä¼ äº‹ä»¶ç›‘å¬å™¨...');

    // æ‹–æ‹½äº‹ä»¶
    newDragDropArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        newDragDropArea.classList.add('dragover');
        console.log('ğŸ”„ æ–‡ä»¶æ‹–æ‹½æ‚¬åœ');
    });

    newDragDropArea.addEventListener('dragleave', (e) => {
        e.preventDefault();
        if (!newDragDropArea.contains(e.relatedTarget)) {
            newDragDropArea.classList.remove('dragover');
            console.log('ğŸ”„ æ–‡ä»¶æ‹–æ‹½ç¦»å¼€');
        }
    });

    newDragDropArea.addEventListener('drop', (e) => {
        e.preventDefault();
        newDragDropArea.classList.remove('dragover');
        const files = e.dataTransfer.files;
        console.log('=== ğŸ¯ æ–‡ä»¶æ‹–æ‹½æ”¾ä¸‹äº‹ä»¶è§¦å‘ ===');
        console.log('æ‹–æ‹½æ–‡ä»¶æ•°é‡:', files.length);
        if (files.length > 0) {
            for (let i = 0; i < files.length; i++) {
                console.log(`æ‹–æ‹½æ–‡ä»¶ ${i + 1}: ${files[i].name} (${files[i].size} bytes)`);
            }
            handleFileSelect(files);
            showToast(`âœ… é€šè¿‡æ‹–æ‹½é€‰æ‹©äº† ${files.length} ä¸ªæ–‡ä»¶ï¼Œè¯·ç‚¹å‡»"å¼€å§‹ä¸Šä¼ "è¿›è¡Œä¸Šä¼ `, 'success');
            
            // æ»šåŠ¨åˆ°ä¸Šä¼ æŒ‰é’®å¹¶é«˜äº®
            const uploadBtn = document.querySelector('.upload-card .btn-primary');
            if (uploadBtn) {
                uploadBtn.scrollIntoView({ behavior: 'smooth', block: 'center' });
                uploadBtn.style.animation = 'pulse 0.6s ease-in-out 3';
            }
        } else {
            console.log('æ‹–æ‹½åŒºåŸŸæ²¡æœ‰æ£€æµ‹åˆ°æœ‰æ•ˆæ–‡ä»¶');
            showToast('æ²¡æœ‰æ£€æµ‹åˆ°æœ‰æ•ˆæ–‡ä»¶', 'warning');
        }
    });

    // ç‚¹å‡»äº‹ä»¶
    newDragDropArea.addEventListener('click', (e) => {
        console.log('ğŸ–±ï¸ ç‚¹å‡»æ–‡ä»¶ä¸Šä¼ åŒºåŸŸ');
        if (e.target !== newFileInput) {
            newFileInput.click();
        }
    });

    // æ–‡ä»¶é€‰æ‹©äº‹ä»¶
    newFileInput.addEventListener('change', (e) => {
        const files = e.target.files;
        console.log('=== ğŸ¯ æ–‡ä»¶é€‰æ‹©äº‹ä»¶è§¦å‘ ===');
        console.log('é€‰æ‹©çš„æ–‡ä»¶æ•°é‡:', files.length);
        if (files.length > 0) {
            for (let i = 0; i < files.length; i++) {
                console.log(`æ–‡ä»¶ ${i + 1}: ${files[i].name} (${files[i].size} bytes)`);
            }
            handleFileSelect(files);
            showToast(`âœ… å·²é€‰æ‹© ${files.length} ä¸ªæ–‡ä»¶ï¼Œè¯·ç‚¹å‡»"å¼€å§‹ä¸Šä¼ "è¿›è¡Œä¸Šä¼ `, 'success');
            
            // æ»šåŠ¨åˆ°ä¸Šä¼ æŒ‰é’®
            const uploadBtn = document.querySelector('.upload-card .btn-primary');
            if (uploadBtn) {
                uploadBtn.scrollIntoView({ behavior: 'smooth', block: 'center' });
                uploadBtn.style.animation = 'pulse 0.6s ease-in-out 3';
            }
        } else {
            console.log('æ²¡æœ‰é€‰æ‹©ä»»ä½•æ–‡ä»¶');
            showToast('æ²¡æœ‰é€‰æ‹©ä»»ä½•æ–‡ä»¶', 'warning');
        }
    });

    console.log('âœ… æ–‡ä»¶ä¸Šä¼ äº‹ä»¶ç›‘å¬å™¨ç»‘å®šå®Œæˆ');
}

// äº‹ä»¶ç›‘å¬å™¨è®¾ç½®
function setupEventListeners() {
    console.log('è®¾ç½®äº‹ä»¶ç›‘å¬å™¨...');
    
    // é…ç½®è¡¨å•ç›‘å¬
    const llmTypeSelect = document.getElementById('llm-type');
    const llmUrlInput = document.getElementById('llm-url');
    const llmModelInput = document.getElementById('llm-model');
    const llmKeyInput = document.getElementById('llm-key');
    
    if (llmTypeSelect) llmTypeSelect.addEventListener('change', updateLLMConfig);
    if (llmUrlInput) llmUrlInput.addEventListener('input', updateLLMConfig);
    if (llmModelInput) llmModelInput.addEventListener('input', updateLLMConfig);
    if (llmKeyInput) llmKeyInput.addEventListener('input', updateLLMConfig);
    
    const embedTypeSelect = document.getElementById('embed-type');
    const embedUrlInput = document.getElementById('embed-url');
    const embedKeyInput = document.getElementById('embed-key');
    const embedModelInput = document.getElementById('embed-model');
    const embedDimInput = document.getElementById('embed-dim');
    
    console.log('è®¾ç½®åµŒå…¥æ¨¡å‹ç›‘å¬å™¨...', { embedTypeSelect: !!embedTypeSelect });
    
    if (embedTypeSelect) {
        embedTypeSelect.addEventListener('change', function() {
            console.log('åµŒå…¥æ¨¡å‹ç±»å‹æ”¹å˜:', this.value);
            toggleEmbeddingConfigDisplay();
            updateEmbeddingConfig();
        });
    }
    if (embedUrlInput) embedUrlInput.addEventListener('input', updateEmbeddingConfig);
    if (embedKeyInput) embedKeyInput.addEventListener('input', updateEmbeddingConfig);
    if (embedModelInput) embedModelInput.addEventListener('input', updateEmbeddingConfig);
    if (embedDimInput) embedDimInput.addEventListener('input', updateEmbeddingConfig);
}

// ç³»ç»ŸçŠ¶æ€æ£€æŸ¥
async function checkSystemStatus() {
    try {
        // æ£€æŸ¥APIæœåŠ¡
        const apiStatus = await fetch(`${API_BASE_URL}/health`);
        updateStatusIndicator('api-status', apiStatus.ok, 'APIæœåŠ¡');

        // æ£€æŸ¥ç³»ç»ŸçŠ¶æ€
        const systemStatus = await fetch(`${API_BASE_URL}/status`);
        if (systemStatus.ok) {
            const data = await systemStatus.json();
            updateStatusIndicator('llm-status', true, 'æœ¬åœ°æ¨¡å‹');
            
            // è·å–çŸ¥è¯†åº“ç»Ÿè®¡
            const kbStats = await fetch(`${API_BASE_URL}/knowledge/stats`);
            if (kbStats.ok) {
                const kbData = await kbStats.json();
                updateStatusIndicator('kb-status', true, 'çŸ¥è¯†åº“');
                
                // è®¡ç®—æ€»æ–‡æ¡£æ•°
                const totalDocs = Object.values(kbData.stats || {})
                    .reduce((sum, stat) => sum + (stat.document_count || 0), 0);
                document.getElementById('doc-count').textContent = totalDocs;
            }
        }
    } catch (error) {
        console.error('ç³»ç»ŸçŠ¶æ€æ£€æŸ¥å¤±è´¥:', error);
        updateStatusIndicator('api-status', false, 'APIæœåŠ¡');
        updateStatusIndicator('llm-status', false, 'LLMæ¨¡å‹');
        updateStatusIndicator('kb-status', false, 'çŸ¥è¯†åº“');
    }
}

// æ›´æ–°çŠ¶æ€æŒ‡ç¤ºå™¨
function updateStatusIndicator(elementId, isOnline, label) {
    const element = document.getElementById(elementId);
    element.textContent = isOnline ? 'åœ¨çº¿' : 'ç¦»çº¿';
    element.className = `status-value ${isOnline ? 'online' : 'offline'}`;
}

// é…ç½®ç®¡ç†
function loadConfiguration() {
    const savedConfig = localStorage.getItem('medicalAiConfig');
    if (savedConfig) {
        currentConfig = JSON.parse(savedConfig);
        applyConfigurationToUI();
    }
}

function applyConfigurationToUI() {
    document.getElementById('llm-type').value = currentConfig.llm.type;
    document.getElementById('llm-url').value = currentConfig.llm.url;
    document.getElementById('llm-model').value = currentConfig.llm.model;
    document.getElementById('llm-key').value = currentConfig.llm.key;
    document.getElementById('llm-temp').value = currentConfig.llm.temperature;
    document.getElementById('temp-value').textContent = currentConfig.llm.temperature;
    
    document.getElementById('embed-type').value = currentConfig.embedding.type;
    document.getElementById('embed-url').value = currentConfig.embedding.url;
    document.getElementById('embed-key').value = currentConfig.embedding.key;
    document.getElementById('embed-model').value = currentConfig.embedding.model;
    document.getElementById('embed-dim').value = currentConfig.embedding.dimension;
    
    // æ›´æ–°åµŒå…¥æ¨¡å‹é…ç½®æ˜¾ç¤º
    toggleEmbeddingConfigDisplay();
}

function updateLLMConfig() {
    currentConfig.llm = {
        type: document.getElementById('llm-type').value,
        url: document.getElementById('llm-url').value,
        model: document.getElementById('llm-model').value,
        key: document.getElementById('llm-key').value,
        temperature: parseFloat(document.getElementById('llm-temp').value)
    };
    saveConfiguration();
}

function updateEmbeddingConfig() {
    currentConfig.embedding = {
        type: document.getElementById('embed-type').value,
        url: document.getElementById('embed-url').value,
        key: document.getElementById('embed-key').value,
        model: document.getElementById('embed-model').value,
        dimension: parseInt(document.getElementById('embed-dim').value)
    };
    saveConfiguration();
}

function saveConfiguration() {
    localStorage.setItem('medicalAiConfig', JSON.stringify(currentConfig));
    
    // å®æ—¶æ›´æ–°åç«¯é…ç½®
    updateBackendConfiguration();
    
    showToast('é…ç½®å·²ä¿å­˜å¹¶ç”Ÿæ•ˆ', 'success');
}

// å®æ—¶æ›´æ–°åç«¯é…ç½®
async function updateBackendConfiguration() {
    try {
        const formData = new FormData();
        formData.append('llm_type', currentConfig.llm.type);
        formData.append('llm_url', currentConfig.llm.url);
        formData.append('llm_model', currentConfig.llm.model);
        formData.append('llm_key', currentConfig.llm.key);
        formData.append('llm_temperature', currentConfig.llm.temperature);
        formData.append('embed_type', currentConfig.embedding.type);
        formData.append('embed_url', currentConfig.embedding.url);
        formData.append('embed_key', currentConfig.embedding.key);
        formData.append('embed_model', currentConfig.embedding.model);
        formData.append('embed_dimension', currentConfig.embedding.dimension);

        const response = await fetch(`${API_BASE_URL}/config/update`, {
            method: 'POST',
            body: formData
        });

        if (response.ok) {
            const result = await response.json();
            console.log('åç«¯é…ç½®æ›´æ–°æˆåŠŸ:', result);
        } else {
            console.error('åç«¯é…ç½®æ›´æ–°å¤±è´¥');
        }
    } catch (error) {
        console.error('åç«¯é…ç½®æ›´æ–°é”™è¯¯:', error);
    }
}

function resetConfiguration() {
    currentConfig = {
        llm: {
            type: 'local',
            url: 'http://192.168.22.191:8000/v1',
            model: '/home/aiteam/.cache/modelscope/hub/models/google/medgemma-27b-text-it/',
            key: 'EMPTY',
            temperature: 0.3
        },
        embedding: {
            type: 'local-api',
            url: 'http://192.168.22.191:8000/v1',
            key: 'EMPTY',
            model: 'auto',
            dimension: 4096
        }
    };
    applyConfigurationToUI();
    saveConfiguration();
    showToast('é…ç½®å·²é‡ç½®', 'info');
}

function exportConfiguration() {
    const configBlob = new Blob([JSON.stringify(currentConfig, null, 2)], {
        type: 'application/json'
    });
    const url = URL.createObjectURL(configBlob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'medical-ai-config.json';
    a.click();
    URL.revokeObjectURL(url);
    showToast('é…ç½®æ–‡ä»¶å·²å¯¼å‡º', 'success');
}

// LLMè¿æ¥æµ‹è¯•
async function testLLMConnection() {
    showLoading('æµ‹è¯•LLMè¿æ¥ä¸­...');
    try {
        const response = await fetch(`${API_BASE_URL}/test/llm`, {
            method: 'POST'
        });
        const result = await response.json();
        
        if (result.success) {
            showToast('LLMè¿æ¥æµ‹è¯•æˆåŠŸ: ' + result.response, 'success');
        } else {
            showToast('LLMè¿æ¥æµ‹è¯•å¤±è´¥: ' + result.message, 'error');
        }
    } catch (error) {
        showToast('LLMè¿æ¥æµ‹è¯•å¤±è´¥: ' + error.message, 'error');
    } finally {
        hideLoading();
    }
}

// åµŒå…¥æ¨¡å‹æµ‹è¯•
async function testEmbeddingModel() {
    showLoading('æµ‹è¯•åµŒå…¥æ¨¡å‹ä¸­...');
    try {
        const response = await fetch(`${API_BASE_URL}/test/embedding`, {
            method: 'POST'
        });
        const result = await response.json();
        
        if (result.success) {
            showToast(`åµŒå…¥æ¨¡å‹æµ‹è¯•æˆåŠŸï¼Œç»´åº¦: ${result.dimension}`, 'success');
        } else {
            showToast('åµŒå…¥æ¨¡å‹æµ‹è¯•å¤±è´¥: ' + result.message, 'error');
        }
    } catch (error) {
        showToast('åµŒå…¥æ¨¡å‹æµ‹è¯•å¤±è´¥: ' + error.message, 'error');
    } finally {
        hideLoading();
    }
}

// æ–‡ä»¶å¤„ç†
function handleFileSelect(files) {
    console.log('=== ğŸ¯ handleFileSelectå‡½æ•°è¢«è°ƒç”¨ ===');
    console.log('ä¼ å…¥çš„fileså‚æ•°:', files);
    console.log('filesæ˜¯å¦ä¸ºç©º:', !files);
    console.log('files.length:', files ? files.length : 'undefined');
    
    if (!files || files.length === 0) {
        console.error('âŒ æ²¡æœ‰æœ‰æ•ˆçš„æ–‡ä»¶ä¼ å…¥');
        currentFiles = [];
        updateFilePreview();
        return;
    }
    
    currentFiles = Array.from(files);
    console.log('âœ… currentFileså·²è®¾ç½®:', currentFiles);
    console.log('âœ… currentFiles.length:', currentFiles.length);
    
    // æ˜¾ç¤ºæ¯ä¸ªæ–‡ä»¶çš„è¯¦ç»†ä¿¡æ¯
    currentFiles.forEach((file, index) => {
        console.log(`æ–‡ä»¶ ${index + 1}:`, {
            name: file.name,
            size: file.size,
            type: file.type,
            lastModified: new Date(file.lastModified).toLocaleString()
        });
    });
    
    updateFilePreview();
    console.log('âœ… handleFileSelectæ‰§è¡Œå®Œæˆ');
}

function updateFilePreview() {
    const dragDropArea = document.getElementById('drag-drop-area');
    const preview = dragDropArea.querySelector('p');
    
    if (currentFiles.length > 0) {        const fileNames = currentFiles.map(f => escapeHtml(f.name)).join(', ');
        preview.innerHTML = `å·²é€‰æ‹© ${currentFiles.length} ä¸ªæ–‡ä»¶:<br><small style="color: #666;">${fileNames}</small>`;
        
        // æ›´æ”¹æ‹–æ‹½åŒºåŸŸæ ·å¼è¡¨ç¤ºæ–‡ä»¶å·²é€‰æ‹©
        dragDropArea.style.borderColor = '#10b981';
        dragDropArea.style.backgroundColor = 'rgba(16, 185, 129, 0.05)';
    } else {
        preview.innerHTML = 'æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„æˆ–ç‚¹å‡»é€‰æ‹©æ–‡ä»¶<br><span class="upload-hint">æ”¯æŒ Excel, CSV, PDF, Word, æ–‡æœ¬æ–‡ä»¶</span>';
        dragDropArea.style.borderColor = '';
        dragDropArea.style.backgroundColor = '';
    }
}

// æ–‡ä»¶ä¸Šä¼ 
async function uploadFiles() {
    console.log('=== ğŸš€ uploadFileså‡½æ•°è¢«è°ƒç”¨ ===');
    console.log('å½“å‰currentFilesçŠ¶æ€:', currentFiles);
    console.log('currentFiles.length:', currentFiles.length);
    console.log('currentFilesæ˜¯å¦ä¸ºæ•°ç»„:', Array.isArray(currentFiles));
    
    if (currentFiles.length === 0) {
        console.error('âŒ currentFilesä¸ºç©ºï¼Œæ— æ³•ä¸Šä¼ ');
        showToast('è¯·å…ˆé€‰æ‹©æ–‡ä»¶', 'warning');
        return;
    }

    const knowledgeType = document.getElementById('kb-type').value;
    const uploadBtn = document.querySelector('.upload-card .btn-primary');
    
    // ç¦ç”¨ä¸Šä¼ æŒ‰é’®å¹¶æ˜¾ç¤ºè¿›åº¦
    uploadBtn.disabled = true;
    uploadBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> æ­£åœ¨ä¸Šä¼ ...';
    
    showLoading(`æ­£åœ¨ä¸Šä¼  ${currentFiles.length} ä¸ªæ–‡ä»¶...`);

    try {
        let successCount = 0;
        let errorCount = 0;
        
        for (let i = 0; i < currentFiles.length; i++) {
            const file = currentFiles[i];
            const formData = new FormData();
            formData.append('file', file);
            formData.append('knowledge_type', knowledgeType);
            formData.append('title', file.name.split('.')[0]);

            try {
                const response = await fetch(`${API_BASE_URL}/knowledge/upload`, {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                
                if (response.ok && result.success) {
                    successCount++;
                    
                    // æ˜¾ç¤ºè¯¦ç»†çš„ä¸Šä¼ ç»“æœä¿¡æ¯
                    const processingInfo = result.processing_info || {};
                    const embeddingSample = result.embeddings_sample || [];
                    
                    let uploadMessage = `æ–‡ä»¶ ${file.name} ä¸Šä¼ æˆåŠŸï¼š
â€¢ æ·»åŠ äº† ${result.records_added} æ¡embeddingè®°å½•
â€¢ å¤„ç†äº† ${result.chunks_count || 'N/A'} ä¸ªæ–‡æœ¬å—`;
                    
                    if (processingInfo.embedding_applied) {
                        uploadMessage += `
â€¢ å‘é‡åŒ–æ¨¡å‹: ${processingInfo.embedding_model || 'N/A'}
â€¢ æˆåŠŸç‡: ${processingInfo.success_rate || 'N/A'}`;
                        
                        if (embeddingSample.length > 0) {
                            uploadMessage += `
â€¢ å‘é‡ç»´åº¦: ${embeddingSample[0].embedding_dimension || 'N/A'}`;
                        }
                        
                        if (processingInfo.embedding_failures > 0) {
                            uploadMessage += `
â€¢ å¤±è´¥æ•°: ${processingInfo.embedding_failures}`;
                        }
                    }
                    
                    showToast(uploadMessage, 'success');
                } else {
                    errorCount++;
                    showToast(`æ–‡ä»¶ ${file.name} ä¸Šä¼ å¤±è´¥: ${result.message || 'æœªçŸ¥é”™è¯¯'}`, 'error');
                }
            } catch (fileError) {
                errorCount++;
                showToast(`æ–‡ä»¶ ${file.name} ä¸Šä¼ å¤±è´¥: ${fileError.message}`, 'error');
            }
        }

        // æ˜¾ç¤ºæ€»ä½“ç»“æœ
        if (successCount > 0) {
            showToast(`æˆåŠŸä¸Šä¼  ${successCount} ä¸ªæ–‡ä»¶`, 'success');
            
            // æ¸…ç©ºæ–‡ä»¶é€‰æ‹©
            currentFiles = [];
            document.getElementById('file-input').value = '';
            updateFilePreview();
            
            // åˆ·æ–°ç»Ÿè®¡å’Œæ–‡ä»¶åˆ—è¡¨
            loadKnowledgeStats();
            loadFileList();
        }
        
        if (errorCount > 0) {
            showToast(`${errorCount} ä¸ªæ–‡ä»¶ä¸Šä¼ å¤±è´¥`, 'warning');
        }
        
    } catch (error) {
        showToast('æ–‡ä»¶ä¸Šä¼ å¤±è´¥: ' + error.message, 'error');
    } finally {
        hideLoading();
        
        // æ¢å¤ä¸Šä¼ æŒ‰é’®
        uploadBtn.disabled = false;
        uploadBtn.innerHTML = '<i class="fas fa-upload"></i> å¼€å§‹ä¸Šä¼ ';
    }
}

// çŸ¥è¯†åº“ç»Ÿè®¡
async function loadKnowledgeStats() {
    try {
        const response = await fetch(`${API_BASE_URL}/knowledge/stats`);
        if (response.ok) {
            const data = await response.json();
            updateKnowledgeStatsChart(data.stats);
            updateStatsDetails(data.stats);
        }
    } catch (error) {
        console.error('åŠ è½½çŸ¥è¯†åº“ç»Ÿè®¡å¤±è´¥:', error);
    }
}

function updateKnowledgeStatsChart(stats) {
    const ctx = document.getElementById('kb-stats-chart');
    if (!ctx) return;

    const labels = Object.keys(stats);
    const data = Object.values(stats).map(stat => stat.document_count || 0);

    if (charts.kbStats) {
        charts.kbStats.destroy();
    }

    charts.kbStats = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: labels,
            datasets: [{
                data: data,
                backgroundColor: [
                    '#2563eb', '#10b981', '#f59e0b', '#ef4444',
                    '#06b6d4', '#8b5cf6', '#f97316', '#84cc16'
                ]
            }]
        },
        options: {
            responsive: true,
            plugins: {
                legend: {
                    position: 'bottom'
                }
            }
        }
    });
}

function updateStatsDetails(stats) {
    const container = document.getElementById('stats-details');
    if (!container) return;

    const total = Object.values(stats).reduce((sum, stat) => sum + (stat.document_count || 0), 0);
    
    container.innerHTML = `
        <div style="margin-top: 1rem;">
            <strong>æ€»æ–‡æ¡£æ•°: ${total}</strong>
            ${Object.entries(stats).map(([type, stat]) => 
                `<div style="display: flex; justify-content: space-between; margin-top: 0.5rem;">
                    <span>${type}:</span>
                    <span>${stat.document_count || 0} æ¡</span>
                </div>`
            ).join('')}
        </div>
    `;
}

// æ–‡ä»¶åˆ—è¡¨
async function loadFileList() {
    try {
        const response = await fetch(`${API_BASE_URL}/knowledge/files`);
        if (response.ok) {
            const data = await response.json();
            updateFileList(data.files);
        }
    } catch (error) {
        console.error('åŠ è½½æ–‡ä»¶åˆ—è¡¨å¤±è´¥:', error);
    }
}

function updateFileList(files) {
    const container = document.getElementById('file-list');
    if (!container) return;

    if (files.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: #64748b;">æš‚æ— å·²ä¸Šä¼ çš„æ–‡ä»¶</p>';
        return;
    }

    container.innerHTML = files.map(file => `
        <div class="file-item">
            <div class="file-info">
                <i class="file-icon fas fa-file"></i>
                <div class="file-details">
                    <h4><a href="#" class="file-name" onclick="viewFileDetails('${file.filename}')">${file.filename}</a></h4>
                    <p>${formatFileSize(file.size)} â€¢ ${formatDate(file.modified)}</p>
                </div>
            </div>
            <button class="btn btn-danger" onclick="deleteFile('${file.filename}')">
                <i class="fas fa-trash"></i> åˆ é™¤
            </button>
        </div>
    `).join('');
}

function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function formatDate(timestamp) {
    return new Date(timestamp * 1000).toLocaleDateString('zh-CN');
}

// åˆ é™¤æ–‡ä»¶
async function deleteFile(filename) {
    if (!confirm(`ç¡®å®šè¦åˆ é™¤æ–‡ä»¶ "${filename}" å—ï¼Ÿ`)) {
        return;
    }

    showLoading('æ­£åœ¨åˆ é™¤æ–‡ä»¶...');
    try {
        const response = await fetch(`${API_BASE_URL}/knowledge/file/${filename}`, {
            method: 'DELETE'
        });

        if (response.ok) {
            showToast(`æ–‡ä»¶ ${filename} åˆ é™¤æˆåŠŸ`, 'success');
            loadFileList();
            loadKnowledgeStats();
        } else {
            throw new Error('åˆ é™¤æ–‡ä»¶å¤±è´¥');
        }
    } catch (error) {
        showToast('åˆ é™¤æ–‡ä»¶å¤±è´¥: ' + error.message, 'error');
    } finally {
        hideLoading();
    }
}

// çŸ¥è¯†åº“æœç´¢
async function searchKnowledge() {
    const query = document.getElementById('search-input').value.trim();
    if (!query) {
        showToast('è¯·è¾“å…¥æœç´¢å…³é”®è¯', 'warning');
        return;
    }

    showLoading('æ­£åœ¨è¿›è¡Œå‘é‡ç›¸ä¼¼åº¦æœç´¢...');
    try {
        const response = await fetch(`${API_BASE_URL}/knowledge/search?query=${encodeURIComponent(query)}&top_k=5`);
        if (response.ok) {
            const data = await response.json();
            displaySearchResults(data.results, data.search_info);
        } else {
            throw new Error('æœç´¢å¤±è´¥');
        }
    } catch (error) {
        showToast('æœç´¢å¤±è´¥: ' + error.message, 'error');
    } finally {
        hideLoading();
    }
}

function displaySearchResults(results, searchInfo = null) {
    const container = document.getElementById('search-results');
    if (!container) return;

    let resultsHtml = '';
    
    // æ˜¾ç¤ºæœç´¢ç»Ÿè®¡ä¿¡æ¯
    if (searchInfo) {
        resultsHtml += `
            <div class="search-info" style="background: #f1f5f9; padding: 1rem; margin-bottom: 1rem; border-radius: 8px;">
                <h4>ğŸ” æœç´¢è¯¦æƒ…</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-top: 0.5rem;">
                    <div><strong>æŸ¥è¯¢:</strong> ${searchInfo.query}</div>
                    <div><strong>æœç´¢æ–‡æ¡£æ•°:</strong> ${searchInfo.total_docs_searched || 0}</div>
                    <div><strong>æ‰¾åˆ°ç»“æœæ•°:</strong> ${searchInfo.results_found || 0}</div>
                    <div><strong>è¿”å›ç»“æœæ•°:</strong> ${searchInfo.results_returned || 0}</div>
                    <div><strong>æŸ¥è¯¢å‘é‡ç»´åº¦:</strong> ${searchInfo.embedding_dimension || 'N/A'}</div>
                    ${searchInfo.avg_similarity ? `<div><strong>å¹³å‡ç›¸ä¼¼åº¦:</strong> ${(searchInfo.avg_similarity * 100).toFixed(1)}%</div>` : ''}
                </div>
                ${searchInfo.error ? `<div style="color: #ef4444; margin-top: 0.5rem;"><strong>é”™è¯¯:</strong> ${searchInfo.error}</div>` : ''}
            </div>
        `;
    }

    if (results.length === 0) {
        resultsHtml += '<p style="text-align: center; color: #64748b;">æœªæ‰¾åˆ°ç›¸å…³æ–‡æ¡£</p>';
        container.innerHTML = resultsHtml;
        return;
    }

    resultsHtml += results.map((result, index) => {
        const similarityPercent = (result.score * 100).toFixed(1);
        const similarityColor = result.score > 0.7 ? '#10b981' : result.score > 0.5 ? '#f59e0b' : '#ef4444';
        
        // ä½¿ç”¨enhanced_metadataå¦‚æœå­˜åœ¨ï¼Œå¦åˆ™ä½¿ç”¨åŸmetadata
        const metadata = result.enhanced_metadata || result.metadata || {};
        
        return `
            <div class="search-result-item" style="border: 1px solid #e2e8f0; padding: 1rem; margin-bottom: 1rem; border-radius: 8px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                    <h4 style="margin: 0;">${result.knowledge_type}</h4>
                    <span style="background: ${similarityColor}; color: white; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.875rem;">
                        ç›¸ä¼¼åº¦: ${similarityPercent}%
                    </span>
                </div>
                <p style="margin: 0.5rem 0; line-height: 1.6;">${result.content.length > 300 ? result.content.substring(0, 300) + '...' : result.content}</p>
                <div style="font-size: 0.875rem; color: #64748b; margin-top: 0.5rem;">
                    ${metadata.source_file ? `<div><strong>æ¥æºæ–‡ä»¶:</strong> ${metadata.source_file}</div>` : ''}
                    ${metadata.chunk_info ? `<div><strong>æ–‡æœ¬å—:</strong> ${metadata.chunk_info}</div>` : ''}
                    ${metadata.upload_time ? `<div><strong>ä¸Šä¼ æ—¶é—´:</strong> ${new Date(metadata.upload_time).toLocaleString()}</div>` : ''}
                    ${metadata.embedding_dimension ? `<div><strong>å‘é‡ç»´åº¦:</strong> ${metadata.embedding_dimension}</div>` : ''}
                    ${result.distance !== undefined ? `<div><strong>è·ç¦»åˆ†æ•°:</strong> ${result.distance.toFixed(4)}</div>` : ''}
                </div>
            </div>
        `;
    }).join('');

    container.innerHTML = resultsHtml;
}

// æ–¹æ¡ˆç”Ÿæˆ
function fillExample(exampleNum) {
    const examples = [
        'è®¾è®¡ä¸€é¡¹TCR-Tç»†èƒè¯ç‰©æ²»ç–—æ™šæœŸè‚ºé³ç™Œçš„IæœŸä¸´åºŠç ”ç©¶ï¼ŒéªŒè¯è¯ç‰©çš„è€å—æ€§ã€å®‰å…¨æ€§å’Œåˆæ­¥æœ‰æ•ˆæ€§',
        'å¼€å±•CAR-Tç»†èƒç–—æ³•æ²»ç–—å¤å‘éš¾æ²»æ€§Bç»†èƒæ·‹å·´ç˜¤çš„IIæœŸä¸´åºŠè¯•éªŒ',
        'è®¾è®¡ä¸€é¡¹å…ç–«æ£€æŸ¥ç‚¹æŠ‘åˆ¶å‰‚è”åˆåŒ–ç–—æ²»ç–—æ™šæœŸèƒƒç™Œçš„IIIæœŸéšæœºå¯¹ç…§è¯•éªŒ'
    ];
    
    document.getElementById('requirement-input').value = examples[exampleNum - 1];
}

async function generateProtocol() {
    const requirement = document.getElementById('requirement-input').value.trim();
    if (!requirement) {
        showToast('è¯·è¾“å…¥ç ”ç©¶éœ€æ±‚æè¿°', 'warning');
        return;
    }

    if (generationInProgress) {
        showToast('ç”Ÿæˆæ­£åœ¨è¿›è¡Œä¸­ï¼Œè¯·ç­‰å¾…å®Œæˆ', 'warning');
        return;
    }

    generationInProgress = true;
    resetProgressBars();
    document.getElementById('results-section').style.display = 'none';

    try {
        // æ¨¡æ‹Ÿç”Ÿæˆè¿›åº¦
        await simulateGenerationProgress();

        // è°ƒç”¨APIç”Ÿæˆæ–¹æ¡ˆ
        const requestData = {
            user_requirement: requirement,
            model_type: currentConfig.llm.type,
            include_quality_check: document.getElementById('include-quality').checked,
            include_literature: document.getElementById('include-literature').checked,
            temperature: currentConfig.llm.temperature
        };

        const response = await fetch(`${API_BASE_URL}/generate`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestData)
        });

        if (response.ok) {
            const result = await response.json();
            displayGenerationResult(result);
            showToast('æ–¹æ¡ˆç”Ÿæˆå®Œæˆ', 'success');
        } else {
            const error = await response.json();
            throw new Error(error.detail || 'ç”Ÿæˆå¤±è´¥');
        }

    } catch (error) {
        showToast('ç”Ÿæˆå¤±è´¥: ' + error.message, 'error');
        setProgressError();
    } finally {
        generationInProgress = false;
    }
}

function resetProgressBars() {
    for (let i = 1; i <= 4; i++) {
        document.getElementById(`progress-${i}`).style.width = '0%';
        const status = document.getElementById(`status-${i}`);
        status.textContent = 'ç­‰å¾…ä¸­';
        status.className = 'progress-status';
    }
}

async function simulateGenerationProgress() {
    const steps = [
        { id: 1, name: 'éœ€æ±‚è§£æ', duration: 1000 },
        { id: 2, name: 'çŸ¥è¯†æ£€ç´¢', duration: 2000 },
        { id: 3, name: 'å†…å®¹ç”Ÿæˆ', duration: 5000 },
        { id: 4, name: 'è´¨é‡æ£€æŸ¥', duration: 1500 }
    ];

    for (const step of steps) {
        updateProgress(step.id, 0, 'è¿›è¡Œä¸­', 'active');
        
        // æ¨¡æ‹Ÿè¿›åº¦å¢é•¿
        for (let progress = 0; progress <= 100; progress += 10) {
            document.getElementById(`progress-${step.id}`).style.width = `${progress}%`;
            await new Promise(resolve => setTimeout(resolve, step.duration / 10));
        }
        
        updateProgress(step.id, 100, 'å·²å®Œæˆ', 'completed');
    }
}

function updateProgress(stepId, percentage, statusText, statusClass) {
    document.getElementById(`progress-${stepId}`).style.width = `${percentage}%`;
    const status = document.getElementById(`status-${stepId}`);
    status.textContent = statusText;
    status.className = `progress-status ${statusClass}`;
}

function setProgressError() {
    for (let i = 1; i <= 4; i++) {
        const status = document.getElementById(`status-${i}`);
        if (!status.classList.contains('completed')) {
            status.textContent = 'å¤±è´¥';
            status.className = 'progress-status error';
            break;
        }
    }
}

function displayGenerationResult(result) {
    const container = document.getElementById('results-content');
    if (!container) return;

    // æ˜¾ç¤ºåŸºæœ¬ä¿¡æ¯
    const basicInfo = `
        <div class="result-summary" style="margin-bottom: 2rem;">
            <h4>ç”Ÿæˆæ‘˜è¦</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-top: 1rem;">
                <div class="stat-item">
                    <strong>è¯ç‰©ç±»å‹:</strong> ${result.extracted_info.drug_type}
                </div>
                <div class="stat-item">
                    <strong>é€‚åº”ç—‡:</strong> ${result.extracted_info.disease}
                </div>
                <div class="stat-item">
                    <strong>è¯•éªŒæœŸåˆ«:</strong> ${result.extracted_info.phase}æœŸ
                </div>
                <div class="stat-item">
                    <strong>è´¨é‡è¯„åˆ†:</strong> ${result.quality_report.overall_score.toFixed(1)}/100
                </div>
            </div>
        </div>
    `;

    // æ˜¾ç¤ºæ–¹æ¡ˆå†…å®¹
    const protocolContent = Object.entries(result.protocol_content).map(([module, content]) => `
        <div class="result-module">
            <div class="result-module-header" onclick="toggleResultModule(this)">
                <h4>${module}</h4>
                <i class="fas fa-chevron-down"></i>
            </div>
            <div class="result-module-content">
                <div style="white-space: pre-wrap; line-height: 1.6;">${content}</div>
            </div>
        </div>
    `).join('');

    // æ˜¾ç¤ºè´¨é‡æŠ¥å‘Š
    const qualityReport = `
        <div class="quality-report" style="margin-top: 2rem;">
            <h4>è´¨é‡è¯„ä¼°æŠ¥å‘Š</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-top: 1rem;">
                ${Object.entries(result.quality_report.module_scores).map(([check, score]) => `
                    <div class="quality-item" style="padding: 1rem; background: #f8fafc; border-radius: 8px;">
                        <div style="font-weight: 500;">${check}</div>
                        <div style="font-size: 1.2rem; color: ${score >= 80 ? '#10b981' : score >= 60 ? '#f59e0b' : '#ef4444'};">
                            ${score}/100
                        </div>
                    </div>
                `).join('')}
            </div>
        </div>
    `;

    // æ˜¾ç¤ºå¯¼å‡ºé€‰é¡¹
    const exportOptions = `
        <div class="export-options" style="margin-top: 2rem; padding-top: 2rem; border-top: 1px solid #e2e8f0;">
            <h4>å¯¼å‡ºé€‰é¡¹</h4>
            <div style="display: flex; gap: 1rem; margin-top: 1rem;">
                <button class="btn btn-primary" onclick="exportResult(${result.id || 'latest'}, 'word')">
                    <i class="fas fa-file-word"></i> å¯¼å‡ºWord
                </button>
                <button class="btn btn-secondary" onclick="exportResult(${result.id || 'latest'}, 'pdf')">
                    <i class="fas fa-file-pdf"></i> å¯¼å‡ºPDF
                </button>
                <button class="btn btn-info" onclick="copyResultAsText()">
                    <i class="fas fa-copy"></i> å¤åˆ¶æ–‡æœ¬
                </button>
            </div>
        </div>
    `;

    container.innerHTML = basicInfo + protocolContent + qualityReport + exportOptions;
    document.getElementById('results-section').style.display = 'block';
}

function toggleResultModule(header) {
    const content = header.nextElementSibling;
    const icon = header.querySelector('i');
    
    if (content.classList.contains('active')) {
        content.classList.remove('active');
        icon.className = 'fas fa-chevron-down';
    } else {
        content.classList.add('active');
        icon.className = 'fas fa-chevron-up';
    }
}

// å¯¼å‡ºç»“æœ
async function exportResult(resultId, format) {
    showLoading(`æ­£åœ¨å¯¼å‡º${format.toUpperCase()}æ–‡æ¡£...`);
    try {
        const response = await fetch(`${API_BASE_URL}/export/${resultId}?format=${format}`, {
            method: 'POST'
        });

        if (response.ok) {
            const result = await response.json();
            showToast(`${format.toUpperCase()}æ–‡æ¡£å¯¼å‡ºæˆåŠŸ: ${result.filename}`, 'success');
        } else {
            throw new Error('å¯¼å‡ºå¤±è´¥');
        }
    } catch (error) {
        showToast('å¯¼å‡ºå¤±è´¥: ' + error.message, 'error');
    } finally {
        hideLoading();
    }
}

function copyResultAsText() {
    const content = document.getElementById('results-content');
    const text = content.innerText;
    
    navigator.clipboard.writeText(text).then(() => {
        showToast('å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
    }).catch(() => {
        showToast('å¤åˆ¶å¤±è´¥', 'error');
    });
}

// å›¾è¡¨åˆå§‹åŒ–
function initializeCharts() {
    // åˆå§‹åŒ–ç›‘æ§å›¾è¡¨
    initMonitorCharts();
}

function initMonitorCharts() {
    const chartConfigs = [
        { id: 'response-time-chart', type: 'line', label: 'APIå“åº”æ—¶é—´ (ms)' },
        { id: 'query-performance-chart', type: 'bar', label: 'æŸ¥è¯¢æ€§èƒ½ (ms)' },
        { id: 'quality-distribution-chart', type: 'pie', label: 'è´¨é‡åˆ†å¸ƒ' },
        { id: 'module-time-chart', type: 'horizontalBar', label: 'æ¨¡å—è€—æ—¶ (s)' }
    ];    chartConfigs.forEach(config => {
        const ctx = document.getElementById(config.id);
        if (ctx) {
            charts[config.id] = createMonitorChart(ctx, config);
        }
    });
}

function createMonitorChart(ctx, config) {
    const baseConfig = {
        type: config.type,
        data: generateMockData(config.type),
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: config.type !== 'pie' ? {
                y: {
                    beginAtZero: true
                }
            } : undefined,
            plugins: {
                legend: {
                    display: config.type === 'pie'
                }
            }
        }
    };

    return new Chart(ctx, baseConfig);
}

function generateMockData(chartType) {
    switch (chartType) {
        case 'line':
            return {
                labels: ['1åˆ†é’Ÿå‰', '2åˆ†é’Ÿå‰', '3åˆ†é’Ÿå‰', '4åˆ†é’Ÿå‰', '5åˆ†é’Ÿå‰'],
                datasets: [{
                    label: 'APIå“åº”æ—¶é—´',
                    data: [120, 150, 100, 180, 140],
                    borderColor: '#2563eb',
                    backgroundColor: 'rgba(37, 99, 235, 0.1)'
                }]
            };
        case 'bar':
            return {
                labels: ['æ–‡æ¡£æ£€ç´¢', 'å‘é‡æœç´¢', 'æ–‡æœ¬ç”Ÿæˆ', 'è´¨é‡æ£€æŸ¥'],
                datasets: [{
                    label: 'æŸ¥è¯¢æ—¶é—´',
                    data: [50, 120, 300, 80],
                    backgroundColor: ['#2563eb', '#10b981', '#f59e0b', '#ef4444']
                }]
            };
        case 'pie':
            return {
                labels: ['ä¼˜ç§€', 'è‰¯å¥½', 'ä¸€èˆ¬', 'éœ€æ”¹è¿›'],
                datasets: [{
                    data: [40, 35, 20, 5],
                    backgroundColor: ['#10b981', '#06b6d4', '#f59e0b', '#ef4444']
                }]
            };
        case 'horizontalBar':
            return {
                labels: ['ç ”ç©¶èƒŒæ™¯', 'ç ”ç©¶è®¾è®¡', 'ç ”ç©¶äººç¾¤', 'ç»™è¯æ–¹æ¡ˆ', 'å®‰å…¨è¯„ä¼°'],
                datasets: [{
                    label: 'ç”Ÿæˆæ—¶é—´',
                    data: [2.5, 3.2, 1.8, 2.1, 2.8],
                    backgroundColor: '#2563eb'
                }]
            };
        default:
            return { labels: [], datasets: [] };
    }
}

function renderProcessCharts() {
    // æ›´æ–°å®æ—¶ç›‘æ§æ•°æ®
    Object.keys(charts).forEach(chartId => {
        if (charts[chartId] && chartId.includes('-chart')) {
            // æ¨¡æ‹Ÿæ•°æ®æ›´æ–°
            const chart = charts[chartId];
            if (chart.data && chart.data.datasets[0]) {
                // éšæœºæ›´æ–°æ•°æ®
                chart.data.datasets[0].data = chart.data.datasets[0].data.map(value => 
                    Math.max(0, value + (Math.random() - 0.5) * 20)
                );
                chart.update();
            }
        }
    });
}

// UIè¾…åŠ©å‡½æ•°
function showLoading(message = 'å¤„ç†ä¸­...') {
    const overlay = document.getElementById('loading-overlay');
    const text = document.getElementById('loading-text');
    text.textContent = message;
    overlay.classList.add('active');
}

function hideLoading() {
    const overlay = document.getElementById('loading-overlay');
    overlay.classList.remove('active');
}

function showToast(message, type = 'info') {
    console.log(`=== æ˜¾ç¤ºToastæ¶ˆæ¯ ===`);
    console.log(`æ¶ˆæ¯: ${message}`);
    console.log(`ç±»å‹: ${type}`);
    
    let container = document.getElementById('toast-container');
    if (!container) {
        console.log('Toastå®¹å™¨ä¸å­˜åœ¨ï¼Œåˆ›å»ºæ–°å®¹å™¨');
        container = document.createElement('div');
        container.id = 'toast-container';
        container.className = 'toast-container';
        document.body.appendChild(container);
    }
    
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <span>${message}</span>
            <button onclick="this.parentElement.parentElement.remove()" style="background: none; border: none; cursor: pointer; color: #64748b; font-size: 1.2rem; padding: 0 5px;">Ã—</button>
        </div>
    `;
    
    container.appendChild(toast);
    console.log('Toastå·²æ·»åŠ åˆ°å®¹å™¨');
    
    // è‡ªåŠ¨ç§»é™¤
    setTimeout(() => {
        if (toast.parentElement) {
            console.log('è‡ªåŠ¨ç§»é™¤Toast');
            toast.remove();
        }
    }, 8000); // å»¶é•¿æ˜¾ç¤ºæ—¶é—´åˆ°8ç§’
}

// å®šæœŸæ›´æ–°ç³»ç»ŸçŠ¶æ€å’Œç›‘æ§æ•°æ®
setInterval(() => {
    if (document.querySelector('.tab-content.active').id === 'home') {
        checkSystemStatus();
    }
    // æ³¨é‡Šæ‰è‡ªåŠ¨åˆ·æ–°è¿›ç¨‹å›¾è¡¨ä»¥é¿å…æ— é™ä¸‹æ‹‰/æ»šåŠ¨é—®é¢˜
    // if (document.querySelector('.tab-content.active').id === 'process') {
    //     renderProcessCharts();
    // }
}, 30000); // 30ç§’æ›´æ–°ä¸€æ¬¡

// èŠå¤©åŠŸèƒ½
let chatStats = {
    rounds: 0,
    totalChars: 0,
    responseTimes: [],
    connectionStatus: 'disconnected'
};

// åˆå§‹åŒ–èŠå¤©åŠŸèƒ½
function initializeChat() {
    // æ›´æ–°æ¸©åº¦æ»‘å—æ˜¾ç¤º
    const chatTempSlider = document.getElementById('chat-temp');
    const chatTempValue = document.getElementById('chat-temp-value');
    
    if (chatTempSlider && chatTempValue) {
        chatTempSlider.addEventListener('input', function() {
            chatTempValue.textContent = this.value;
        });
    }
    
    // å›è½¦é”®å‘é€æ¶ˆæ¯
    const chatInput = document.getElementById('chat-input');
    if (chatInput) {
        chatInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
    }
    
    // æ›´æ–°å½“å‰æ¨¡å‹æ˜¾ç¤º
    updateCurrentModelDisplay();
    
    // æ£€æŸ¥è¿æ¥çŠ¶æ€ checkChatConnection();
}

// æ›´æ–°å½“å‰æ¨¡å‹æ˜¾ç¤º
function updateCurrentModelDisplay() {
    const modelDisplay = document.getElementById('current-model-display');
    if (modelDisplay) {
        modelDisplay.textContent = `${currentConfig.llm.type} - ${currentConfig.llm.model}`;
    }
}

// æ£€æŸ¥èŠå¤©è¿æ¥çŠ¶æ€
async function checkChatConnection() {
    try {
        const response = await fetch(`${API_BASE_URL}/test/llm`, {
            method: 'POST'
        });
        const result = await response.json();
        
        chatStats.connectionStatus = result.success ? 'connected' : 'error';
        updateChatStats();
        
    } catch (error) {
        chatStats.connectionStatus = 'disconnected';
        updateChatStats();
    }
}

// å‘é€æ¶ˆæ¯
async function sendMessage() {
    const chatInput = document.getElementById('chat-input');
    const sendBtn = document.getElementById('send-btn');
    const message = chatInput.value.trim();
    
    if (!message) {
        showToast('è¯·è¾“å…¥æ¶ˆæ¯å†…å®¹', 'warning');
        return;
    }
    
    // æ¸…ç©ºè¾“å…¥æ¡†å¹¶ç¦ç”¨å‘é€æŒ‰é’®
    chatInput.value = '';
    sendBtn.disabled = true;
    sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> å‘é€ä¸­...';
    
    // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°èŠå¤©åŒºåŸŸ
    addMessageToChat('user', message);
    
    // æ˜¾ç¤ºåŠ è½½æŒ‡ç¤ºå™¨
    const typingIndicator = showTypingIndicator();
    
    const startTime = Date.now();
    
    try {
        const response = await fetch(`${API_BASE_URL}/chat`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message: message,
                temperature: parseFloat(document.getElementById('chat-temp').value)
            })
        });
        
        const result = await response.json();
        const responseTime = Date.now() - startTime;
        
        // ç§»é™¤åŠ è½½æŒ‡ç¤ºå™¨
        removeTypingIndicator(typingIndicator);
        
        if (result.success) {
            // æ·»åŠ AIå›å¤åˆ°èŠå¤©åŒºåŸŸ
            addMessageToChat('assistant', result.response, responseTime);
            
            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            chatStats.rounds++;
            chatStats.totalChars += message.length + result.response.length;
            chatStats.responseTimes.push(responseTime);
            chatStats.connectionStatus = 'connected';
            updateChatStats();
            
            showToast('æ¶ˆæ¯å‘é€æˆåŠŸ', 'success');
        } else {
            throw new Error(result.message || 'å‘é€å¤±è´¥');
        }
        
    } catch (error) {
        // ç§»é™¤åŠ è½½æŒ‡ç¤ºå™¨
        removeTypingIndicator(typingIndicator);
        
        // æ·»åŠ é”™è¯¯æ¶ˆæ¯
        addMessageToChat('assistant', `æŠ±æ­‰ï¼Œå‘ç”Ÿäº†é”™è¯¯: ${error.message}`, 0, true);
        
        chatStats.connectionStatus = 'error';
        updateChatStats();
        
        showToast('æ¶ˆæ¯å‘é€å¤±è´¥: ' + error.message, 'error');
    } finally {
        // æ¢å¤å‘é€æŒ‰é’®
        sendBtn.disabled = false;
        sendBtn.innerHTML = '<i class="fas fa-paper-plane"></i> å‘é€';
        chatInput.focus();
    }
}

// å‘é€å¿«é€Ÿé—®é¢˜
function sendQuickQuestion(question) {
    document.getElementById('chat-input').value = question;
    sendMessage();
}

// æ·»åŠ æ¶ˆæ¯åˆ°èŠå¤©åŒºåŸŸ
function addMessageToChat(role, content, responseTime = 0, isError = false) {
    const chatMessages = document.getElementById('chat-messages');
    const welcome = chatMessages.querySelector('.chat-welcome');
    
    // ç§»é™¤æ¬¢è¿ä¿¡æ¯
    if (welcome) {
        welcome.remove();
    }
    
    const messageDiv = document.createElement('div');
    messageDiv.className = `message message-${role}`;
    
    const timestamp = new Date().toLocaleTimeString();
    let metaInfo = timestamp;
    
    if (role === 'assistant' && responseTime > 0) {
        metaInfo += ` â€¢ å“åº”æ—¶é—´: ${responseTime}ms`;
    }
    
    // å¦‚æœæ˜¯AIåŠ©æ‰‹çš„å›å¤ä¸”ä¸æ˜¯é”™è¯¯æ¶ˆæ¯ï¼Œä½¿ç”¨markdownæ¸²æŸ“
    let processedContent;
    if (role === 'assistant' && !isError && typeof marked !== 'undefined' && typeof DOMPurify !== 'undefined') {
        try {
            // é…ç½®markedé€‰é¡¹
            marked.setOptions({
                breaks: true,
                gfm: true,
                headerIds: false,
                mangle: false,
                sanitize: false
            });
            
            // ä½¿ç”¨markedæ¸²æŸ“markdownå¹¶ç”¨DOMPurifyæ¸…ç†HTML
            const htmlContent = marked.parse(content);
            processedContent = DOMPurify.sanitize(htmlContent);
        } catch (error) {
            console.warn('Markdownæ¸²æŸ“å¤±è´¥ï¼Œä½¿ç”¨çº¯æ–‡æœ¬:', error);
            processedContent = content.replace(/\n/g, '<br>');
        }
    } else {
        processedContent = content.replace(/\n/g, '<br>');
    }
    
    messageDiv.innerHTML = `
        <div class="message-content ${isError ? 'error' : ''} ${role === 'assistant' && !isError ? 'markdown-content' : ''}">
            ${processedContent}
            <div class="message-meta">
                <span>${metaInfo}</span>
            </div>
        </div>
    `;
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

// æ˜¾ç¤ºè¾“å…¥æŒ‡ç¤ºå™¨
function showTypingIndicator() {
    const chatMessages = document.getElementById('chat-messages');
    const indicator = document.createElement('div');
    indicator.className = 'message message-assistant';
    indicator.innerHTML = `
        <div class="typing-indicator">
            <span>AIæ­£åœ¨æ€è€ƒ</span>
            <div class="typing-dots">
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
            </div>
        </div>
    `;
    
    chatMessages.appendChild(indicator);
    chatMessages.scrollTop = chatMessages.scrollHeight;
    
    return indicator;
}

// ç§»é™¤è¾“å…¥æŒ‡ç¤ºå™¨
function removeTypingIndicator(indicator) {
    if (indicator && indicator.parentNode) {
        indicator.parentNode.removeChild(indicator);
    }
}

// æ¸…ç©ºèŠå¤©è®°å½•
function clearChat() {
    if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰èŠå¤©è®°å½•å—ï¼Ÿ')) {
        const chatMessages = document.getElementById('chat-messages');
        chatMessages.innerHTML = `
            <div class="chat-welcome">
                <div class="welcome-icon">
                    <i class="fas fa-robot"></i>
                </div>
                <h3>æ¬¢è¿ä½¿ç”¨åŒ»å­¦AIåŠ©æ‰‹</h3>
                <p>æ‚¨å¯ä»¥åœ¨è¿™é‡Œç›´æ¥ä¸é…ç½®çš„LLMæ¨¡å‹å¯¹è¯</p>
                <p class="model-info">å½“å‰æ¨¡å‹ï¼š<span id="current-model-display">${currentConfig.llm.type} - ${currentConfig.llm.model}</span></p>
            </div>
        `;
        
        // é‡ç½®ç»Ÿè®¡ä¿¡æ¯
        chatStats = {
            rounds: 0,
            totalChars: 0,
            responseTimes: [],
            connectionStatus: chatStats.connectionStatus
        };
        updateChatStats();
        
        showToast('èŠå¤©è®°å½•å·²æ¸…ç©º', 'info');
    }
}

// æ›´æ–°èŠå¤©ç»Ÿè®¡ä¿¡æ¯
function updateChatStats() {
    document.getElementById('chat-rounds').textContent = chatStats.rounds;
    document.getElementById('total-chars').textContent = chatStats.totalChars;
    
    // è®¡ç®—å¹³å‡å“åº”æ—¶é—´
    const avgResponseTime = chatStats.responseTimes.length > 0 
        ? Math.round(chatStats.responseTimes.reduce((a, b) => a + b, 0) / chatStats.responseTimes.length)
        : 0;
    document.getElementById('avg-response-time').textContent = `${avgResponseTime}ms`;
    
    // æ›´æ–°è¿æ¥çŠ¶æ€
    const statusElement = document.getElementById('connection-status');
    const statusMap = {
        'connected': { text: 'å·²è¿æ¥', class: 'online' },
        'disconnected': { text: 'æœªè¿æ¥', class: 'offline' },
        'error': { text: 'é”™è¯¯', class: 'error' }
    };
    
    const status = statusMap[chatStats.connectionStatus];
    statusElement.textContent = status.text;
    statusElement.className = `stat-value ${status.class}`;
}

// æŸ¥çœ‹æ–‡ä»¶è¯¦æƒ…
async function viewFileDetails(filename) {
    showLoading('æ­£åœ¨åŠ è½½æ–‡ä»¶è¯¦æƒ…...');
    
    console.log('=== ğŸ” æŸ¥çœ‹æ–‡ä»¶è¯¦æƒ…è°ƒè¯•ä¿¡æ¯ ===');
    console.log('ä¼ å…¥æ–‡ä»¶å:', filename);
    console.log('æ–‡ä»¶åç±»å‹:', typeof filename);
    console.log('æ–‡ä»¶åé•¿åº¦:', filename.length);
    console.log('æ–‡ä»¶åUTF-8å­—èŠ‚:', new TextEncoder().encode(filename));
    
    try {
        // æ„å»ºAPI URL - è®©FastAPIè‡ªåŠ¨å¤„ç†ç¼–ç 
        const encodedFilename = encodeURIComponent(filename);
        const url = `${API_BASE_URL}/knowledge/file/${encodedFilename}/details`;
        
        console.log('åŸå§‹æ–‡ä»¶å:', filename);
        console.log('ç¼–ç åæ–‡ä»¶å:', encodedFilename);
        console.log('å®Œæ•´è¯·æ±‚URL:', url);
        console.log('API_BASE_URL:', API_BASE_URL);
        
        // æ·»åŠ è¯¦ç»†çš„fetché…ç½®
        const fetchOptions = {
            method: 'GET',
            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json',
            }
        };
        
        console.log('ğŸ“¡ å‘é€è¯·æ±‚...');
        console.log('è¯·æ±‚é€‰é¡¹:', fetchOptions);
        
        const response = await fetch(url, fetchOptions);
        
        console.log('ğŸ“¥ æ”¶åˆ°å“åº”:', {
            status: response.status,
            statusText: response.statusText,
            headers: Object.fromEntries(response.headers.entries()),
            url: response.url
        });
        
        if (!response.ok) {
            // å°è¯•è§£æé”™è¯¯å“åº”
            let errorText = '';
            try {
                const errorData = await response.json();
                errorText = errorData.detail || errorData.error || JSON.stringify(errorData);
                console.log('âŒ é”™è¯¯å“åº”JSON:', errorData);
            } catch (e) {
                errorText = await response.text();
                console.log('âŒ é”™è¯¯å“åº”æ–‡æœ¬:', errorText);
            }
            
            let errorMessage = `è·å–æ–‡ä»¶è¯¦æƒ…å¤±è´¥ (${response.status})`;
            let suggestion = '';
            
            if (response.status === 404) {
                errorMessage = 'æ–‡ä»¶è¯¦æƒ…æœªæ‰¾åˆ°';
                suggestion = `
                <br><br><strong>å¯èƒ½çš„åŸå› ï¼š</strong>
                <br>â€¢ æ–‡ä»¶åç¼–ç é—®é¢˜ï¼š${filename}
                <br>â€¢ URLç¼–ç åï¼š${encodedFilename}
                <br>â€¢ æ–‡ä»¶å¯èƒ½æœªæ­£ç¡®ä¸Šä¼ åˆ°çŸ¥è¯†åº“
                <br>â€¢ æ–‡ä»¶çš„embeddingæ•°æ®å¯èƒ½ä¸¢å¤±
                <br><br><strong>å»ºè®®ï¼š</strong>
                <br>1. æ£€æŸ¥åç«¯æ—¥å¿—ä¸­çš„è°ƒè¯•ä¿¡æ¯
                <br>2. å°è¯•é‡æ–°ä¸Šä¼ æ­¤æ–‡ä»¶
                <br>3. æ£€æŸ¥çŸ¥è¯†åº“ç»Ÿè®¡ä¿¡æ¯
                <br><br><strong>è¯¦ç»†é”™è¯¯ï¼š</strong><br>${errorText}`;
            } else if (response.status === 500) {
                errorMessage = 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯';
                suggestion = `<br><br><strong>è¯¦ç»†é”™è¯¯ï¼š</strong><br>${errorText}`;
            }
            
            showToast(errorMessage + suggestion, 'error');
            return;
        }
        
        const data = await response.json();
        console.log('âœ… æˆåŠŸå“åº”:', data);
        
        if (!data.success) {
            console.log('âŒ APIè¿”å›å¤±è´¥:', data.error);
            let errorMessage = data.error || 'è·å–æ–‡ä»¶è¯¦æƒ…å¤±è´¥';
            let debugInfo = '';
            
            if (data.debug_info) {
                debugInfo = `
                <br><br><strong>è°ƒè¯•ä¿¡æ¯ï¼š</strong>
                <br>â€¢ æœç´¢çš„æ–‡ä»¶åï¼š${data.debug_info.searched_filename}
                <br>â€¢ æœç´¢çš„é›†åˆï¼š${data.debug_info.searched_collections?.join(', ')}
                <br>â€¢ æ–‡ä»¶åç¼–ç ï¼š${data.debug_info.filename_encoding}`;
            }
            
            showToast(errorMessage + debugInfo, 'error');
            return;
        }
        
        // æ˜¾ç¤ºæ–‡ä»¶è¯¦æƒ…
        displayFileDetails(data);
        
    } catch (error) {
        console.error('ğŸ’¥ è¯·æ±‚å¼‚å¸¸:', error);
        showToast(`ç½‘ç»œè¯·æ±‚å¤±è´¥: ${error.message}<br><br>è¯·æ£€æŸ¥ï¼š<br>â€¢ åç«¯æœåŠ¡æ˜¯å¦æ­£å¸¸è¿è¡Œ<br>â€¢ ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸<br>â€¢ APIåœ°å€æ˜¯å¦æ­£ç¡®: ${API_BASE_URL}`, 'error');
    } finally {
        hideLoading();
    }
}

// æ˜¾ç¤ºæ–‡ä»¶è¯¦æƒ…
function displayFileDetails(data) {
    const modal = document.getElementById('file-details-modal');
    const title = document.getElementById('file-details-title');
      // è®¾ç½®æ ‡é¢˜ï¼Œæ˜¾ç¤ºæˆªæ–­çŠ¶æ€
    const truncatedIndicator = data.content_truncated ? 
        ' <span class="truncated-badge"><i class="fas fa-cut"></i> å†…å®¹å·²æˆªæ–­</span>' : '';
    title.innerHTML = `<i class="fas fa-file-alt"></i> ${escapeHtml(data.filename)}${truncatedIndicator}`;
    
    // å¡«å……æ–‡ä»¶åŸºæœ¬ä¿¡æ¯
    const fileInfoContent = document.getElementById('file-info-content');
    fileInfoContent.innerHTML = `        <div class="info-item">
            <span class="info-label">æ–‡ä»¶å:</span>
            <span class="info-value">${escapeHtml(data.filename)}</span>
        </div>
        <div class="info-item">
            <span class="info-label">åŸå§‹å¤§å°:</span>
            <span class="info-value">${formatFileSize(data.file_stats.original_size)}</span>
        </div>
        <div class="info-item">
            <span class="info-label">åˆ†å—æ•°é‡:</span>
            <span class="info-value">${data.file_stats.chunks_count}</span>
        </div>        <div class="info-item">
            <span class="info-label">çŸ¥è¯†åº“ç±»å‹:</span>
            <span class="info-value">${escapeHtml(String(data.file_stats.knowledge_types || 'æœªçŸ¥'))}</span>
        </div>
        ${data.content_truncated ? `
        <div class="info-item warning">
            <span class="info-label">å†…å®¹çŠ¶æ€:</span>
            <span class="info-value"><i class="fas fa-exclamation-triangle"></i> å†…å®¹è¿‡é•¿å·²æˆªæ–­æ˜¾ç¤º</span>
        </div>
        ` : ''}
    `;
    
    // å¡«å……embeddingä¿¡æ¯
    const embeddingInfoContent = document.getElementById('embedding-info-content');
    const embeddingInfo = data.embedding_info;
    embeddingInfoContent.innerHTML = `
        <div class="info-item">
            <span class="info-label">æ€»åµŒå…¥æ•°:</span>
            <span class="info-value">${embeddingInfo.total_embeddings}</span>
        </div>
        <div class="info-item">
            <span class="info-label">å‘é‡ç»´åº¦:</span>
            <span class="info-value">${embeddingInfo.embedding_dimensions || 'N/A'}</span>
        </div>
        <div class="info-item">
            <span class="info-label">å¹³å‡å—é•¿åº¦:</span>
            <span class="info-value">${Math.round(embeddingInfo.avg_chunk_length || 0)} å­—ç¬¦</span>
        </div>        <div class="info-item">
            <span class="info-label">çŸ¥è¯†åº“ç±»å‹:</span>
            <span class="info-value">${Array.isArray(embeddingInfo.knowledge_types) ? embeddingInfo.knowledge_types.join(', ') : String(embeddingInfo.knowledge_types || 'æœªçŸ¥')}</span>
        </div>
    `;
    
    // æ˜¾ç¤ºåŸå§‹æ–‡ä»¶å†…å®¹ï¼ˆæ™ºèƒ½å¤„ç†é•¿å†…å®¹ï¼‰
    displayOriginalContent(data);
      // è®¾ç½®åˆ†å—è¿‡æ»¤å™¨é€‰é¡¹
    const chunkFilter = document.getElementById('chunk-filter');
    if (chunkFilter && data.chunks && Array.isArray(data.chunks)) {
        const knowledgeTypes = [...new Set(data.chunks.map(chunk => chunk.knowledge_type || 'æœªçŸ¥'))];
        chunkFilter.innerHTML = '<option value="all">æ‰€æœ‰åˆ†å—</option>' + 
            knowledgeTypes.map(type => `<option value="${escapeHtml(type)}">${escapeHtml(type)}</option>`).join('');
    }
    
    // å­˜å‚¨åˆ†å—æ•°æ®ä»¥ä¾›è¿‡æ»¤ä½¿ç”¨
    window.currentFileChunks = data.chunks || [];
    window.currentFileData = data;
    currentPage = 1;
    displayChunks(window.currentFileChunks);

    // æ˜¾ç¤ºæ¨¡æ€æ¡†
    modal.style.display = 'flex';
}

// æ˜¾ç¤ºæ–‡ä»¶åˆ†å—
function displayChunks(chunks) {
    const chunksContainer = document.getElementById('chunks-container');
    if (!chunksContainer) {
        console.error('chunks-container å…ƒç´ æœªæ‰¾åˆ°');
        return;
    }

    if (!chunks || chunks.length === 0) {
        chunksContainer.innerHTML = '<div class="empty-state">è¯¥æ–‡ä»¶æ²¡æœ‰åˆ†å—æ•°æ®</div>';
        return;
    }

    const chunksHtml = chunks.map((chunk, index) => `
        <div class="chunk-item">
            <div class="chunk-header">
                <div class="chunk-meta">
                    <span>åˆ†å— ${index + 1}</span>
                    <span>ç±»å‹: ${escapeHtml(chunk.knowledge_type || 'æœªçŸ¥')}</span>
                    <span>é•¿åº¦: ${chunk.content.length} å­—ç¬¦</span>
                </div>
                <button class="copy-btn" onclick="copyChunkContent(${index})" title="å¤åˆ¶å†…å®¹">
                    <i class="fas fa-copy"></i>
                </button>
            </div>
            <div class="chunk-content" id="chunk-${index}">
                ${escapeHtml(chunk.content)}
            </div>
        </div>
    `).join('');

    chunksContainer.innerHTML = chunksHtml;
}

// å¤åˆ¶åˆ†å—å†…å®¹
function copyChunkContent(chunkIndex) {
    const chunkElement = document.getElementById(`chunk-${chunkIndex}`);
    if (chunkElement) {
        const textToCopy = chunkElement.textContent;
        navigator.clipboard.writeText(textToCopy).then(() => {
            showToast('åˆ†å—å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
        }).catch(err => {
            console.error('å¤åˆ¶å¤±è´¥:', err);
            showToast('å¤åˆ¶å¤±è´¥', 'error');
        });
    }
}

// æ™ºèƒ½æ˜¾ç¤ºåŸå§‹æ–‡ä»¶å†…å®¹
function displayOriginalContent(data) {
    const originalContent = document.getElementById('original-content');
    const panelHeader = originalContent.closest('.content-panel').querySelector('.panel-header');
    
    // å¦‚æœå†…å®¹è¢«æˆªæ–­ï¼Œæ˜¾ç¤ºé¢„è§ˆæ¨¡å¼
    if (data.content_truncated) {
        const previewContent = data.content_preview || data.original_content.substring(0, 1000) + '...';
        const fullContent = data.original_content;
        
        // æ›´æ–°é¢æ¿æ ‡é¢˜ä»¥æ˜¾ç¤ºæˆªæ–­çŠ¶æ€
        const headerTitle = panelHeader.querySelector('h4');
        headerTitle.innerHTML = `<i class="fas fa-file-text"></i> åŸå§‹æ–‡ä»¶å†…å®¹ <span class="content-badge truncated">å·²æˆªæ–­</span>`;
        
        // æ·»åŠ å±•å¼€/æŠ˜å æ§åˆ¶æŒ‰é’®
        const controls = panelHeader.querySelector('.panel-controls');
        controls.innerHTML = `
            <button class="btn btn-sm content-toggle-btn" onclick="toggleOriginalContent()" id="content-toggle-btn">
                <i class="fas fa-expand-alt"></i> æ˜¾ç¤ºå®Œæ•´å†…å®¹
            </button>
            <button class="btn btn-sm" onclick="copyToClipboard('original-content')">
                <i class="fas fa-copy"></i> å¤åˆ¶
            </button>
        `;
        
        // è®¾ç½®å†…å®¹ï¼ˆé»˜è®¤æ˜¾ç¤ºé¢„è§ˆï¼‰
        originalContent.innerHTML = `
            <div class="content-preview-section">
                <div class="content-warning">
                    <i class="fas fa-info-circle"></i>
                    å†…å®¹è¿‡é•¿ï¼Œå·²æ˜¾ç¤ºå‰ ${previewContent.length} å­—ç¬¦ã€‚å®Œæ•´å†…å®¹åŒ…å« ${fullContent.length} å­—ç¬¦ã€‚
                </div>
                <div class="content-text" id="content-text">${escapeHtml(previewContent)}</div>
                <div class="content-actions">
                    <button class="expand-btn" onclick="toggleOriginalContent()">
                        <i class="fas fa-expand-alt"></i> æ˜¾ç¤ºå®Œæ•´å†…å®¹
                    </button>
                </div>
            </div>
        `;
        
        // å­˜å‚¨å®Œæ•´å†…å®¹ä¾›åç»­ä½¿ç”¨
        originalContent.setAttribute('data-full-content', fullContent);
        originalContent.setAttribute('data-preview-content', previewContent);
        originalContent.setAttribute('data-expanded', 'false');
        
    } else {
        // å†…å®¹æœªè¢«æˆªæ–­ï¼Œæ­£å¸¸æ˜¾ç¤º
        const headerTitle = panelHeader.querySelector('h4');
        headerTitle.innerHTML = `<i class="fas fa-file-text"></i> åŸå§‹æ–‡ä»¶å†…å®¹`;
        
        const controls = panelHeader.querySelector('.panel-controls');
        controls.innerHTML = `
            <button class="btn btn-sm" onclick="copyToClipboard('original-content')">
                <i class="fas fa-copy"></i> å¤åˆ¶
            </button>
        `;
        
        originalContent.textContent = data.original_content || 'æ— æ³•è¯»å–åŸå§‹æ–‡ä»¶å†…å®¹';
    }
}

// åˆ‡æ¢åŸå§‹å†…å®¹æ˜¾ç¤ºæ¨¡å¼
function toggleOriginalContent() {
    const originalContent = document.getElementById('original-content');
    const toggleBtn = document.getElementById('content-toggle-btn');
    const contentText = document.getElementById('content-text');
    const expandBtn = originalContent.querySelector('.expand-btn');
    const isExpanded = originalContent.getAttribute('data-expanded') === 'true';
    
    const fullContent = originalContent.getAttribute('data-full-content');
    const previewContent = originalContent.getAttribute('data-preview-content');
    
    if (isExpanded) {
        // åˆ‡æ¢åˆ°é¢„è§ˆæ¨¡å¼
        contentText.textContent = previewContent;
        originalContent.setAttribute('data-expanded', 'false');
        
        if (toggleBtn) {
            toggleBtn.innerHTML = '<i class="fas fa-expand-alt"></i> æ˜¾ç¤ºå®Œæ•´å†…å®¹';
        }
        if (expandBtn) {
            expandBtn.innerHTML = '<i class="fas fa-expand-alt"></i> æ˜¾ç¤ºå®Œæ•´å†…å®¹';
        }
    } else {
        // åˆ‡æ¢åˆ°å®Œæ•´æ¨¡å¼
        contentText.textContent = fullContent;
        originalContent.setAttribute('data-expanded', 'true');
        
        if (toggleBtn) {
            toggleBtn.innerHTML = '<i class="fas fa-compress-alt"></i> æ˜¾ç¤ºé¢„è§ˆ';
        }
        if (expandBtn) {
            expandBtn.innerHTML = '<i class="fas fa-compress-alt"></i> æ˜¾ç¤ºé¢„è§ˆ';
        }
    }
}

// åˆ‡æ¢åˆ†å—å†…å®¹æ˜¾ç¤º
function toggleChunkContent(chunkIndex) {
    const chunkItem = document.querySelector(`[data-chunk-index="${chunkIndex}"]`);
    if (!chunkItem) return;
    
    const toggleBtn = chunkItem.querySelector('.toggle-content-btn');
    const fullContentDiv = chunkItem.querySelector('.content-full');
    const previewDiv = chunkItem.querySelector('.content-preview');
    
    if (!toggleBtn || !fullContentDiv) return;
    
    const isExpanded = fullContentDiv.style.display !== 'none';
    
    if (isExpanded) {
        // åˆ‡æ¢åˆ°é¢„è§ˆæ¨¡å¼
        fullContentDiv.style.display = 'none';
        previewDiv.style.display = 'block';
        toggleBtn.innerHTML = '<i class="fas fa-expand-alt"></i> æ˜¾ç¤ºå®Œæ•´å†…å®¹';
    } else {
        // åˆ‡æ¢åˆ°å®Œæ•´æ¨¡å¼
        fullContentDiv.style.display = 'block';
        previewDiv.style.display = 'none';
        toggleBtn.innerHTML = '<i class="fas fa-compress-alt"></i> æ”¶èµ·å†…å®¹';
    }
}

// è¿‡æ»¤åˆ†å—
function filterChunks() {
    const filterValue = document.getElementById('chunk-filter').value;
    const allChunks = window.currentFileChunks || [];
    
    if (filterValue === 'all') {
        displayChunks(allChunks);
    } else {
        const filteredChunks = allChunks.filter(chunk => chunk.knowledge_type === filterValue);
        displayChunks(filteredChunks);
    }
}

// åˆ†é¡µç›¸å…³å‡½æ•°
function goToPage(pageNumber) {
    currentPage = pageNumber;
    displayChunks(filteredChunks);
}

// å¤åˆ¶å†…å®¹åˆ°å‰ªè´´æ¿
function copyToClipboard(elementId) {
    const element = document.getElementById(elementId);
    if (!element) return;
    
    let textToCopy = '';
    
    if (elementId === 'original-content') {
        // è·å–åŸå§‹å†…å®¹çš„æ–‡æœ¬
        const contentText = element.querySelector('#content-text');
        if (contentText) {
            textToCopy = contentText.textContent;
        } else {
            textToCopy = element.textContent;
        }
    } else {
        textToCopy = element.textContent;
    }
    
    navigator.clipboard.writeText(textToCopy).then(() => {
        showToast('å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
    }).catch(err => {
        console.error('å¤åˆ¶å¤±è´¥:', err);
        showToast('å¤åˆ¶å¤±è´¥', 'error');
    });
}

// å…³é—­æ–‡ä»¶è¯¦æƒ…æ¨¡æ€æ¡†
function closeFileDetailsModal() {
    const modal = document.getElementById('file-details-modal');
    if (modal) {
        modal.style.display = 'none';
    }
    
    // æ¸…ç†æ•°æ®
    window.currentFileChunks = [];
    window.currentFileData = null;
}

// æ¨¡æ€æ¡†æ ‡ç­¾é¡µåˆ‡æ¢
function switchModalTab(tabName) {
    // ç§»é™¤æ‰€æœ‰æ ‡ç­¾æŒ‰é’®çš„activeçŠ¶æ€
    document.querySelectorAll('.modal-tab-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // éšè—æ‰€æœ‰æ ‡ç­¾é¢æ¿
    document.querySelectorAll('.tab-panel').forEach(panel => {
        panel.classList.remove('active');
    });
    
    // æ¿€æ´»é€‰ä¸­çš„æ ‡ç­¾
    const targetBtn = document.querySelector(`[data-tab="${tabName}"]`);
    const targetPanel = document.getElementById(tabName);
    
    if (targetBtn) targetBtn.classList.add('active');
    if (targetPanel) targetPanel.classList.add('active');
}

// åˆå§‹åŒ–æ¨¡æ€æ¡†äº‹ä»¶ç›‘å¬å™¨
function initializeModalEventListeners() {
    // æ¨¡æ€æ¡†æ ‡ç­¾åˆ‡æ¢
    document.querySelectorAll('.modal-tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            switchModalTab(btn.dataset.tab);
        });
    });
    
    // ç‚¹å‡»æ¨¡æ€æ¡†èƒŒæ™¯å…³é—­
    const modal = document.getElementById('file-details-modal');
    if (modal) {
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                closeFileDetailsModal();
            }
        });
    }
    
    // ESCé”®å…³é—­æ¨¡æ€æ¡†
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            const modal = document.getElementById('file-details-modal');
            if (modal && modal.style.display === 'block') {
                closeFileDetailsModal();
            }
        }
    });
}

// æ˜¾ç¤ºæ¨¡æ€æ¡†
function showFileDetailsModal() {
    const modal = document.getElementById('file-details-modal');
    if (modal) {
        modal.style.display = 'block';
        // é»˜è®¤æ˜¾ç¤ºæ¦‚è§ˆæ ‡ç­¾
        switchModalTab('overview');
    }
}